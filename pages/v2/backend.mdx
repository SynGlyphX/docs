# Backend 

## Features

Express.js server that is deployed as an AWS lambda function.

- Express.js server running on AWS Lambda
- Very low cost, scalability out of the box
- Server packaged up using eslint for small deployment size and quick on-demand start in Lambda
- All infrastructure defined in Terraform, easy to change and extend
- Infrastructure easily rolled out with dedicated npm script
- Deployment automated using Node.js module
- TypeScript, ESLint and Prettier configured

## Config

The following key properties need to be configured for this template:

- **Lambda Name**: The [name](https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-FunctionName) to be used for this lambda. Lambda names need to be unique for the AWS Region
- **API Domain**: `https://api.glyphx.co/`
- **Hosted Zone Domain**: `api.glyphx.co`
- **CORS Header**: `https://app.glyphx.co` should be supplied. To learn more about CORS, see the [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) in the MDN docs.

Stand up infra:

```
yarn infra up [deploymentName]

```

This will be either `yarn infra up dev` or `yarn infra up prod` depending on your choice of deployment. Note that running this command can take a while.

Deploy infa:

```
yarn deploy [deploymentName]

```

This will either be `yarn deploy dev` or `yarn deploy prod` depending on your choice of deployment during project configuration.

The entry point for defining new routes is in `src/server.ts`. Modify or add new routes to the server here.

All infrastructure for this module is defined in Terraform. You can find the Terraform files for this template in the directory `[moduleDir]/infra/aws`. You can define multiple deployments for this template, for instance for development, staging and production environments.

The deployments and their respective configurations are defined in `[moduleDir]/stack.json`.

The configuration tool will define one deployment. This will be either `dev` or `prod` depending on your choice during project configuration.

Infrastructure commands for this template can be run using `yarn`. There are four commands in total:

- `yarn infra up`: For standing up infrastructure.
- `yarn infra plan`: For running [Terraform plan](https://www.terraform.io/docs/commands/plan.html).
- `yarn infra apply`: For running [Terraform apply](https://www.terraform.io/docs/commands/apply.html).
- `yarn infra destroy`: For destroying all infrastructure using [Terraform destroy](https://www.terraform.io/docs/commands/destroy.html).
- `yarn infra upgrade`: For upgrading the Terraform versions (supported by the template). To upgrade to an arbitrary version, use `yarn infra terraform`.
- `yarn infra terraform`: For running arbitrary [Terraform commands](https://www.terraform.io/cli/commands).

For each command, the deployment they should be applied to must be specified.

```
yarn infra [command] [deploymentName]

```

For instance, to stand up the infrastructure for the `dev` deployment, the following command would need to be issued:

```
yarn infra up dev

```

Generally you will only need to run `yarn infra up`. However, if you are familiar with Terraform and want more fine-grained control over the deployment of your infrastructure, you can also use the other commands as required.

Note that for running `yarn infra terraform`, you will need to specify which command line arguments you want to provide to Terraform. By default, no extra arguments are provided:

```
yarn infra terraform [deployment] plan

```

If extra arguments are needed, such as variables, you can use the `--inject-variables` option, such as for running `terraform plan`:

```
yarn infra terraform [deployment] --inject-variables plan

```

If you want to interact with the remote backend, you can also provide the `--inject-backend-config` option, such as for running `terraform init`:

```
yarn infra terraform [deployment] --inject-backend-config init

```

Deploy:

```
yarn deploy [deploymentName]

```

Environment variables are defined in the Terraform source code for this template. Specifically they are defined in the `infra/aws/lambda.tf` file in the resource `resource "aws_lambda_function" "main"`. By default, there is one environment variable specified that identifies the deployment used.

```
 environment {
    variables = {
      STACK_DEPLOYMENT = var.name
    }
  }

```

Add your environment variables into the `variables` map:

```
 environment {
    variables = {
      STACK_DEPLOYMENT = var.name
      YOUR_ENV_VAR = 'your env var value'
    }
  }

```

Usually environment variables should have different values depending on which environment the server is deployed to. This can be accomplished using Terraform variables. Change your variable declaration to the following:

```
YOUR_ENV_VAR = var.my_env

```

Then go into the file `infra/aws/variables.tf` and add the following definition:

```
variable "my_env" {
  description = "My environment variable"
  type = string
}

```

And finally add this variable to all deployment configurations in `stack.json`:

```
      "configuration": {
        "lambdaName": "my-lambda",
        "apiDomain": "api.mysite.com",
        "hostedZoneDomain": "mysite.com",
        "cors": "https://mysite.com",
        "myEnv": "Value for deployment"
      }

```

Note that the Terraform variable `my_env` translates to `myEnv` in the JSON definition (Just remove all `_` and make the first character after `_` uppercase for your variable definitions).

Lastly, to support local development make sure to define the variable correctly in all `scripts` in `package.json`. Specifically, you may want to define them for `"test"`, `"test-ci"` and `"watch"`.

```
    "test": "MY_ENV=localvalue jest --passWithNoTests --watch --config=jest.config.js",
    "test-ci": "MY_ENV=localvalue jest --passWithNoTests --config=jest.config.js --detectOpenHandles",
    "watch": "PORT=8731 MY_ENV=localvalue nodemon --config nodemon.json --exec 'yarn node dist/src/local.js'"

```

Note that for credentials and other values that should not be committed to source code, it may be better to store these in AWS Secrets Manager and retrieve them using the AWS SDK based on the `process.env.STACK_DEPLOYMENT` value provided.

It is also possible to provide the value of Terraform variables through environment variables during build time. For instance, if you have defined the variable `my_env`, simply provide the environment variable `MY_ENV` when calling `yarn infra`.

```
MY_ENV=value yarn infra up prod

```

This works very well in combination with secrets for GitHub actions.

```
- name: Deploy API
  run: |
    yarn workspace my-api infra up prod
  env:
    MY_ENV: ${{secrets.MY_ENV}}
    AWS_USER_NAME: stack-prod
    AWS_ACCESS_KEY_ID: ${{secrets.PROD_AWS_ACCESS_KEY_ID}}
    AWS_SECRET_ACCESS_KEY: ${{secrets.PROD_AWS_SECRET_ACCESS_KEY}}
    AWS_DEFAULT_REGION: us-west-2

```

After applying `yarn infra up [deployment]` and `yarn deploy [deployment]` it is not possible to call the API at `https://[configuration.apiDomain]`. An error such as `Address cannot be resolved` or `DNSProbe failed` is reported.

This is caused by changes to the deployed DNS hosted zone needing some time to propagate through the DNS network. Wait for 10-30 min and the API should be able to be called without problems. To validate your DNS name has been configured correctly, go to the [AWS Route 53 Console](https://aws.amazon.com/route53/), choose the region you have deployed, and validate there is a correct entry for the hosted zone you have selected. There should be an A entry such as the following:

```
[apiDomain].[hostedZone] A [id].cloudfront.net.

```

This module requires further security hardening when deployed in critical production applications. Specifically the lambda is given the role `arn:aws:iam::aws:policy/AdministratorAccess"` and this will grant the lambda access to all resources on the AWS account, including the ability to create and destroy infrastructure. It is therefore recommended to grant this lambda only rights to resources it needs access to, such as read and write permissions for an S3 bucket. This can be modified in `infra/aws/lambda.tf` in the resource `resource "aws_iam_role_policy_attachment" "lambda_admin_role_attach"`.
