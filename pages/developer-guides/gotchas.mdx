# Gotchas

## Serverless AWS infrastructure is structurally different.

Deployments on Vercel or deployments as stand alone Node.js applications have important differences. Thus there are a couple of limitations to keep in mind:

- When standing up infrastructure for this template, a new certificate will be automatically obtained from AWS Certificate Manager. AWS has a default limit of the number of SSL certificates per account. If you are reaching this limit, you can simply make a service request with AWS to increase it.
- Pre-fetching does not work in some situations, for instance when statically rendering pages using `getStaticPaths`. As a workaround, we use vanilla `a` elements.
- Delay in deploying new dynamic routes. Since dynamic routes are implemented using Lambda@Edge functions, it can take a while for dynamic routes to start working. This is because once a new dynamic routes is added, a new Lambda@Edge function needs to be deployed. You can check the state of the CloudFront distribution in the AWS console. If no new dynamic routes have been added, everything should work as expected directly after the deployment.
- Redirect domain configured as CNAME rather than its own bucket and CloudFront distribution due to [this known limitation](https://www.reddit.com/r/aws/comments/7jyisk/https_redirect_on_s3_bucket_access_denied_error/)
- No support for a dynamic route and pages in the same directory. Place dynamic routes into sub directories, such as:

```
[id]/index.tsx
dummy.tsx

```

Next.js supports static file serving by [placing files into a public/ folder](https://nextjs.org/docs/basic-features/static-file-serving). This is useful for files such as `favicon.ico`. This module by default provides support for `favicon.ico` files but if you want to add other files, these may not be captured by the [CloudFront behaviours configured in Terraform](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/cloudfront_distribution#cache-behavior-arguments).

Next.js may try to resolve these files as dynamic paths, which may result in the files not being found. To fix this, go into `infra/aws/root.tf` and add additional `ordered_cache_behaviours` as required.

For instance, if you want to serve a file `/myfile.png` provided in `public/myfile.png` and this file should be cached in CloudFront, add the following behaviour:

```
  ordered_cache_behavior {
    path_pattern     = "myfile.png"
    allowed_methods  = ["GET", "HEAD", "OPTIONS"]
    cached_methods   = ["GET", "HEAD", "OPTIONS"]
    target_origin_id = "origin-bucket-${aws_s3_bucket.website_root.id}"

    forwarded_values {
      query_string = false
      headers      = ["Origin"]

      cookies {
        forward = "none"
      }
    }

    min_ttl                = 0
    default_ttl            = 86400
    max_ttl                = 31536000
    compress               = true
    viewer_protocol_policy = "redirect-to-https"
  }

```

If you would like all files in `/myfolder` provided in the folder `public/myfolder` and not cache these, provide the following behaviour:

```
  ordered_cache_behavior {
    path_pattern     = "myfolder/*"
    allowed_methods  = ["GET", "HEAD", "OPTIONS"]
    cached_methods   = ["GET", "HEAD", "OPTIONS"]
    target_origin_id = "origin-bucket-${aws_s3_bucket.website_root.id}"

    forwarded_values {
      query_string = false
      headers      = ["Origin"]

      cookies {
        forward = "none"
      }
    }

    min_ttl                = 0
    default_ttl            = tostring(var.default_cache_duration)
    max_ttl                = 1200
    compress               = true
    viewer_protocol_policy = "redirect-to-https"
  }

```

Instead of seeing the page, you may see an error message like the following:

```
502 ERROR
The request could not be satisfied.
The Lambda function returned invalid json: The json output must be an object type. We can't connect to the server for this app or website at this time. There might be too much traffic or a configuration error. Try again later, or contact the app or website owner.
If you provide content to customers through CloudFront, you can find steps to troubleshoot and help prevent this error by reviewing the CloudFront documentation.
Generated by cloudfront (CloudFront)
Request ID: JIQQuxOxsXdcyHuUKxbA88YeFs_NH0h7B6xbG-SZFN88byb5WffF0A==

```

This is most likely due to the deployment not having worked correctly. Try deploying the package again with `yarn deploy [deploymentName]`.

When running `yarn infra up [deploymentName], you may get AccessDenied errors such as the following:

```
Error: error getting S3 Bucket CORS configuration: AccessDenied: Access Denied
        status code: 403, request id: 1Z1VFR1N5RAMFZ9W, host id: mYdqmUJ8Vo+t845tuW9NNYF8WVnKxlbynRAir4BoMKHKB5kcFjM3uiGkJpQAHGHxusa6sHzcazs=

```

There are a number of possible causes for this:

- You may have configured your AWS user incorrectly. Please see [AWS Configuration](https://docs.goldstack.party/docs/goldstack/configuration#aws-configuration) for details on how to configure your AWS user.
- You may accidentaly have a Terraform state in your module. That can happen if you create new modules by copy and pasting from an existing module. In this case, delete the following two folders in your module: `infra/aws/.terraform` and `infra/aws/terraform.tfstate.d`.

Sometimes when running `yarn infra destroy [deploymentName]` Terraform reports an error that the edge lambda cannot be deleted.

```
Error: Error deleting Lambda Function: InvalidParameterValueException: Lambda was unable to delete arn:aws:lambda:us-east-1:475629728374:function:[function name]-edge:2 because it is a replicated function. Please see our documentation for Deleting Lambda@Edge Functions and Replicas

```

In that case, simply run `yarn infra destroy [deploymentName]` again until it is successful.
